<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è¯­éŸ³åˆæˆåŠ©æ‰‹</title>
  <style>
      * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
      }

      body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          min-height: 100vh;
          display: flex;
          justify-content: center;
          align-items: center;
          padding: 20px;
      }

      .container {
          background: rgba(255, 255, 255, 0.95);
          backdrop-filter: blur(10px);
          border-radius: 20px;
          box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
          padding: 40px;
          width: 100%;
          max-width: 700px;
          animation: slideUp 0.6s ease-out;
      }

      @keyframes slideUp {
          from {
              opacity: 0;
              transform: translateY(30px);
          }
          to {
              opacity: 1;
              transform: translateY(0);
          }
      }

      h1 {
          text-align: center;
          color: #333;
          margin-bottom: 30px;
          font-size: 2.5em;
          font-weight: 300;
      }

      .form-group {
          margin-bottom: 25px;
      }

      label {
          display: block;
          margin-bottom: 8px;
          color: #555;
          font-weight: 500;
          font-size: 1.1em;
      }

      textarea, input, select {
          width: 100%;
          padding: 15px;
          border: 2px solid #e0e0e0;
          border-radius: 10px;
          font-size: 16px;
          transition: all 0.3s ease;
          background: rgba(255, 255, 255, 0.8);
      }

      textarea:focus, input:focus, select:focus {
          outline: none;
          border-color: #667eea;
          box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
          transform: translateY(-2px);
      }

      textarea {
          resize: vertical;
          min-height: 120px;
          font-family: inherit;
      }

      .controls {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 20px;
          margin-bottom: 25px;
      }

      .checkbox-group {
          display: flex;
          align-items: center;
          gap: 10px;
          grid-column: span 2;
      }

      input[type="checkbox"] {
          width: auto;
          transform: scale(1.2);
      }

      button {
          width: 100%;
          padding: 15px;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border: none;
          border-radius: 10px;
          font-size: 18px;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
          margin-bottom: 20px;
      }

      button:hover:not(:disabled) {
          transform: translateY(-2px);
          box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
      }

      button:active {
          transform: translateY(0);
      }

      button:disabled {
          background: #ccc;
          cursor: not-allowed;
      }

      .loading {
          display: none;
          text-align: center;
          margin: 20px 0;
          color: #667eea;
          font-weight: 500;
      }

      .spinner {
          display: inline-block;
          width: 20px;
          height: 20px;
          border: 3px solid #f3f3f3;
          border-top: 3px solid #667eea;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin-right: 10px;
      }

      @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
      }

      @keyframes pulse {
          0% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.05); opacity: 0.9; }
          100% { transform: scale(1); opacity: 1; }
      }

      .audio-container {
          text-align: center;
          margin-top: 20px;
          padding: 20px;
          background: rgba(102, 126, 234, 0.1);
          border-radius: 10px;
          display: none;
      }

      audio {
          width: 100%;
          margin-top: 15px;
      }

      .download-btn {
          margin-top: 15px;
          padding: 10px 20px;
          background: #28a745;
          color: white;
          text-decoration: none;
          border-radius: 5px;
          display: inline-block;
          transition: all 0.3s ease;
      }

      .download-btn:hover {
          background: #218838;
          transform: translateY(-2px);
      }

      .error {
          background: #f8d7da;
          color: #721c24;
          padding: 15px;
          border-radius: 10px;
          margin-top: 20px;
          display: none;
      }

      .success {
          background: #d4edda;
          color: #155724;
          padding: 15px;
          border-radius: 10px;
          margin-top: 20px;
          display: none;
      }

      /* æ–°å¢ï¼šæµå¼æ’­æ”¾çŠ¶æ€æ˜¾ç¤º */
      .stream-status {
          background: rgba(102, 126, 234, 0.1);
          border-radius: 10px;
          padding: 20px;
          margin: 20px 0;
          display: none;
      }

      .status-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          gap: 15px;
          margin-bottom: 15px;
      }

      .status-item {
          text-align: center;
          padding: 10px;
          background: rgba(255, 255, 255, 0.7);
          border-radius: 8px;
      }

      .status-label {
          font-size: 0.9em;
          color: #666;
          margin-bottom: 5px;
      }

      .status-value {
          font-weight: bold;
          color: #333;
      }

      .buffer-progress {
          width: 100%;
          height: 8px;
          background: rgba(255, 255, 255, 0.3);
          border-radius: 4px;
          overflow: hidden;
          margin-top: 10px;
      }

      .buffer-fill {
          height: 100%;
          background: linear-gradient(90deg, #4CAF50, #45a049);
          width: 0%;
          transition: width 0.3s ease;
      }

      .stream-log {
          background: rgba(0, 0, 0, 0.1);
          border-radius: 8px;
          padding: 15px;
          height: 120px;
          overflow-y: auto;
          font-family: monospace;
          font-size: 12px;
          line-height: 1.4;
          margin-top: 15px;
      }

      @media (max-width: 768px) {
          .container {
              padding: 20px;
              margin: 10px;
          }

          h1 {
              font-size: 2em;
          }

          .controls {
              grid-template-columns: 1fr;
          }

          .checkbox-group {
              grid-column: span 1;
          }
      }
  </style>
</head>
<body>
  <div class="container">
      <h1>ğŸµ è¯­éŸ³åˆæˆåŠ©æ‰‹</h1>
      
      <form id="ttsForm">
          <div class="form-group">
              <label for="ttsText">ğŸ“ è¾“å…¥è¦åˆæˆçš„æ–‡æœ¬ï¼š</label>
              <textarea id="ttsText" placeholder="è¯·è¾“å…¥æ‚¨æƒ³è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬..." required></textarea>
          </div>

          <div class="form-group">
              <label for="instructText">ğŸ’¡ æŒ‡ä»¤æ–‡æœ¬ï¼ˆå¯é€‰ï¼‰ï¼š</label>
              <textarea id="instructText" placeholder="è¾“å…¥è¯­éŸ³æŒ‡ä»¤æˆ–é£æ ¼æè¿°..." value="è¯·ç”¨è‡ªç„¶æµç•…çš„è¯­è°ƒæœ—è¯»">è¯·ç”¨è‡ªç„¶æµç•…çš„è¯­è°ƒæœ—è¯»</textarea>
          </div>

          <div class="controls">
              <div class="form-group">
                  <label for="speed">âš¡ è¯­é€Ÿï¼š</label>
                  <input type="range" id="speed" min="0.5" max="2.0" step="0.1" value="1.0">
                  <span id="speedValue">1.0x</span>
              </div>

              <div class="checkbox-group">
                  <input type="checkbox" id="stream">
                  <label for="stream">ğŸ”„ æµå¼åˆæˆ</label>
              </div>
          </div>

          <button type="submit" id="generateBtn">
              ğŸ¤ ç”Ÿæˆè¯­éŸ³
          </button>
      </form>

      <div class="loading" id="loading">
          <div class="spinner"></div>
          æ­£åœ¨ç”Ÿæˆè¯­éŸ³ï¼Œè¯·ç¨å€™...
      </div>

      <!-- æ–°å¢ï¼šæµå¼æ’­æ”¾çŠ¶æ€ -->
      <div class="stream-status" id="streamStatus">
          <h3>ğŸ“¡ æµå¼æ’­æ”¾çŠ¶æ€</h3>
          <div class="status-grid">
              <div class="status-item">
                  <div class="status-label">ç¼“å†²çŠ¶æ€</div>
                  <div class="status-value" id="bufferStatus">å‡†å¤‡ä¸­</div>
              </div>
              <div class="status-item">
                  <div class="status-label">æ’­æ”¾çŠ¶æ€</div>
                  <div class="status-value" id="playStatus">æœªæ’­æ”¾</div>
              </div>
              <div class="status-item">
                  <div class="status-label">ç¼“å†²å¤§å°</div>
                  <div class="status-value" id="bufferSize">0 KB</div>
              </div>
              <div class="status-item">
                  <div class="status-label">æ’­æ”¾æ—¶é•¿</div>
                  <div class="status-value" id="playTime">00:00</div>
              </div>
          </div>
          <div class="buffer-progress">
              <div class="buffer-fill" id="bufferFill"></div>
          </div>
          
          <!-- æµå¼æ’­æ”¾æ§åˆ¶æŒ‰é’® -->
          <div style="text-align: center; margin: 15px 0;">
              <button id="stopStreamBtn" onclick="streamPlayer.stop()" style="background: #dc3545; color: white; padding: 8px 16px; border: none; border-radius: 5px; cursor: pointer; display: none;">
                  â¹ï¸ åœæ­¢æµå¼æ’­æ”¾
              </button>
              <button id="resumeStreamBtn" onclick="streamPlayer.resumeAudioContext()" style="background: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 5px; cursor: pointer; display: none; margin-left: 10px;">
                  ğŸ”Š å¯ç”¨éŸ³é¢‘æ’­æ”¾
              </button>
          </div>
          
          <div class="stream-log" id="streamLog">
              <div>ğŸµ æµå¼æ’­æ”¾å™¨å·²å°±ç»ª</div>
              <div>ğŸ’¡ æ”¯æŒé¢„ç¼“å†²å’Œè‡ªåŠ¨æ’­æ”¾åŠŸèƒ½</div>
          </div>
      </div>

      <div class="audio-container" id="audioContainer">
          <h3>ğŸµ ç”Ÿæˆçš„è¯­éŸ³</h3>
          <audio id="audioPlayer" controls></audio>
          <br>
          <a id="downloadLink" class="download-btn" download="tts_output.wav">
              ğŸ“¥ ä¸‹è½½éŸ³é¢‘æ–‡ä»¶
          </a>
      </div>

      <div class="error" id="errorMsg"></div>
      <div class="success" id="successMsg"></div>
  </div>

  <script>
    // è¯·æ ¹æ®æ‚¨çš„å®é™…æƒ…å†µä¿®æ”¹base_urlé…ç½®ï¼š
      // âš ï¸ é‡è¦ï¼šè¯·æ ¹æ®æ‚¨çš„å®é™…æƒ…å†µé…ç½®base_url
      // å¦‚æœåœ¨LinuxæœåŠ¡å™¨æœ¬æœºè®¿é—®ï¼š
      const base_url = "http://localhost:8800"
      // å¦‚æœä»Windowsæœºå™¨è®¿é—®LinuxæœåŠ¡å™¨ï¼Œè¯·æ›¿æ¢ä¸ºLinuxæœåŠ¡å™¨çš„å®é™…IPåœ°å€ï¼š
      //const base_url = "http://js1.blockelite.cn:15088"  // ä¿®æ”¹ä¸ºæœ¬åœ°æœåŠ¡å™¨ï¼ˆè¯·æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ï¼‰
      //const base_url = "http://192.168.137.128:8800"  
      // æ³¨æ„ï¼šå¦‚æœæ‚¨çš„LinuxæœåŠ¡å™¨IPæ˜¯å…¶ä»–åœ°å€ï¼Œè¯·ä¿®æ”¹ä¸ºæ­£ç¡®çš„IP:8800  
      const sampleRate1 = 24000;
      // æµå¼éŸ³é¢‘æ’­æ”¾å™¨ç±»
      class StreamingAudioPlayer {
          constructor() {
              this.audioContext = null;
              this.audioChunks = []; // å­˜å‚¨åŸå§‹éŸ³é¢‘ç‰‡æ®µï¼ˆç”¨äºä¸‹è½½ï¼‰
              this.isStreaming = false;
              this.isPlaying = false;
              this.isPrebuffering = true;
              this.totalBytes = 0;
              this.playedBytes = 0;
              this.isWavFormat = true; // é»˜è®¤å‡è®¾ä¸ºWAVæ ¼å¼
              
              // Web Audio API æµå¼æ’­æ”¾ç›¸å…³
              this.audioPreBuffer = []; // é¢„ç¼“å†²é˜Ÿåˆ—
              this.nextPlayTime = 0;
              this.audioScheduler = null;
              this.timeUpdater = null;
              this.playStarted = false;
              
              // ç¼“å†²è®¾ç½® - ä¼˜åŒ–è·¨å¹³å°å…¼å®¹æ€§
              this.prebufferSize = 96 * 1024;  // 96KB é¢„ç¼“å†²å¤§å°ï¼Œæé«˜ç¨³å®šæ€§
              this.maxBufferSize = 768 * 1024; // 768KB æœ€å¤§ç¼“å†²ï¼Œå‡å°‘ç½‘ç»œæŠ–åŠ¨å½±å“
              this.chunkThreshold = 24 * 1024; // 24KB æ¯æ¬¡å¤„ç†å—å¤§å°ï¼Œä¸åç«¯ä¸€è‡´
              this.preBufferThreshold = 3;     // 3å—é¢„ç¼“å†²é˜ˆå€¼ï¼Œæé«˜æ’­æ”¾æµç•…åº¦
              
              // ç½‘ç»œç»Ÿè®¡
              this.lastChunkTime = 0;
              this.chunkIntervals = [];
              this.rtfStats = {
                  chunksReceived: 0,
                  chunksPlayed: 0,
                  totalAudioDuration: 0,
                  startTime: null,
                  networkJitter: 0,
                  avgChunkInterval: 0
              };
              
              this.audioElement = document.getElementById('audioPlayer');
              this.mediaSource = null;
              this.sourceBuffer = null;
              this.startTime = null;
              this.playbackStarted = false;
              this.currentBlob = null;
              this.pendingChunks = [];
              
              this.initializeAudioContext();
              this.setupEventListeners();

          }
          
          async initializeAudioContext() {
              try {
                  this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                  this.log('âœ… éŸ³é¢‘ä¸Šä¸‹æ–‡åˆå§‹åŒ–æˆåŠŸ');
                  this.updateStreamButtons(); // æ›´æ–°æŒ‰é’®çŠ¶æ€
              } catch (error) {
                  this.log('âŒ éŸ³é¢‘ä¸Šä¸‹æ–‡åˆå§‹åŒ–å¤±è´¥: ' + error.message);
              }
          }
          
          setupEventListeners() {
              // HTML5 Audioå…ƒç´ ä¸»è¦ç”¨äºä¸‹è½½éŸ³é¢‘çš„æ’­æ”¾
              // æµå¼æ’­æ”¾ä¸»è¦ä½¿ç”¨Web Audio API
              
              this.audioElement.addEventListener('playing', () => {
                  this.log('ğŸ“» HTML5éŸ³é¢‘å¼€å§‹æ’­æ”¾ï¼ˆç”¨äºä¸‹è½½éŸ³é¢‘ï¼‰');
              });
              
              this.audioElement.addEventListener('pause', () => {
                  this.log('â¸ï¸ HTML5éŸ³é¢‘æš‚åœ');
              });
              
              this.audioElement.addEventListener('ended', () => {
                  this.log('â¹ï¸ HTML5éŸ³é¢‘æ’­æ”¾ç»“æŸ');
              });
              
              this.audioElement.addEventListener('error', (e) => {
                  this.log('âŒ HTML5éŸ³é¢‘æ’­æ”¾é”™è¯¯: ' + (e.target.error?.message || 'æœªçŸ¥é”™è¯¯'));
              });
          }
          
          // å¼€å§‹æµå¼æ’­æ”¾
          async startStreaming() {
              this.reset();
              this.isStreaming = true;
              this.isPrebuffering = true;
              this.updateStatus('é¢„ç¼“å†²ä¸­', 'bufferStatus');
              this.updateStatus('å‡†å¤‡ä¸­', 'playStatus');
              this.updateStreamButtons(); // æ›´æ–°æŒ‰é’®çŠ¶æ€
              this.log('ğŸ”„ å¼€å§‹æµå¼æ’­æ”¾ï¼Œç­‰å¾…éŸ³é¢‘æ•°æ®...');
          }
          
          // å¤„ç†çœŸæ­£çš„æµå¼å“åº”ï¼ˆPCMæ•°æ®æµï¼‰
          async processRealTimeStream(responseBody) {
              const reader = responseBody.getReader();
              let receivedBytes = 0;
              let chunkCount = 0;
              let pendingData = new Uint8Array(0); // å­˜å‚¨ä¸å®Œæ•´çš„éŸ³é¢‘å¸§
              
              this.log('ğŸ“¡ å¼€å§‹å¤„ç†çœŸå®PCMæµå¼æ•°æ®');
              
              try {
                  while (true) {
                      const { done, value } = await reader.read();
                      
                      if (done) {
                          this.log('âœ… çœŸæ­£æµå¼æ•°æ®æ¥æ”¶å®Œæˆ');
                          
                          // å¤„ç†å‰©ä½™çš„æ•°æ®
                          if (pendingData.length > 0) {
                              this.log(`ğŸ“¦ å¤„ç†å‰©ä½™æ•°æ®: ${pendingData.length} å­—èŠ‚`);
                              await this.processRawPCMChunk(pendingData);
                          }
                          
                          this.finishStreaming();
                          break;
                      }
                      
                      if (value && value.byteLength > 0) {
                          chunkCount++;
                          receivedBytes += value.byteLength;
                          
                          // åˆå¹¶ä¹‹å‰çš„æœªå¤„ç†æ•°æ®å’Œæ–°æ•°æ®
                          const combined = new Uint8Array(pendingData.length + value.byteLength);
                          combined.set(pendingData, 0);
                          combined.set(new Uint8Array(value), pendingData.length);
                          
                          // ç¡®ä¿å¤„ç†çš„æ˜¯å®Œæ•´çš„16ä½æ ·æœ¬ï¼ˆæ¯ä¸ªæ ·æœ¬2å­—èŠ‚ï¼‰
                          const completeBytes = Math.floor(combined.length / 2) * 2;
                          
                          if (completeBytes > 0) {
                              const completeData = combined.slice(0, completeBytes);
                              pendingData = combined.slice(completeBytes);
                              
                              this.log(`ğŸ“¥ å¤„ç†PCMæµå¼å— ${chunkCount}: ${value.byteLength}å­—èŠ‚ â†’ ${completeData.length}å­—èŠ‚(å®Œæ•´), å¾…å¤„ç†${pendingData.length}å­—èŠ‚`);
                              
                              // ç›´æ¥å¤„ç†PCMæ•°æ®
                              await this.processRawPCMChunk(completeData);
                              
                              // æ›´æ–°ç»Ÿè®¡
                              const currentTime = Date.now();
                              if (this.lastChunkTime > 0) {
                                  const interval = currentTime - this.lastChunkTime;
                                  this.chunkIntervals.push(interval);
                                  if (this.chunkIntervals.length > 20) {
                                      this.chunkIntervals.shift();
                                  }
                                  this.updateNetworkStats();
                              }
                              this.lastChunkTime = currentTime;
                              
                              // æ›´æ–°UI
                              this.totalBytes += completeData.length;
                              this.updateBufferSize();
                              
                              // æ¨¡æ‹Ÿè¿›åº¦ï¼ˆç”±äºä¸çŸ¥é“æ€»å¤§å°ï¼Œä½¿ç”¨å—æ•°æ¥ä¼°ç®—ï¼‰
                              const estimatedProgress = Math.min((chunkCount * 5), 90); // æ¯å—5%ï¼Œæœ€å¤š90%
                              this.updateBufferProgress(estimatedProgress);
                          } else {
                              // æ•°æ®ä¸è¶³ä¸€ä¸ªå®Œæ•´æ ·æœ¬ï¼Œä¿ç•™åˆ°ä¸‹æ¬¡å¤„ç†
                              pendingData = combined;
                              this.log(`â³ æ•°æ®å—ä¸å®Œæ•´ï¼Œç­‰å¾…æ›´å¤šæ•°æ®(å½“å‰${combined.length}å­—èŠ‚)`);
                          }
                      }
                  }
                  
                  this.log(`ğŸ“Š æµå¼æ¥æ”¶ç»Ÿè®¡: æ€»è®¡${chunkCount}å—, ${this.formatBytes(receivedBytes)}`);
                  
              } catch (error) {
                  this.log('âŒ çœŸæ­£æµå¼å¤„ç†é”™è¯¯: ' + error.message);
                  throw error;
              }
          }
          
          // å¤„ç†åŸå§‹PCMæ•°æ®å—
          async processRawPCMChunk(pcmData) {
              // ä¿å­˜åŸå§‹PCMæ•°æ®ç”¨äºä¸‹è½½
              this.audioChunks.push(new Uint8Array(pcmData));
              
              // ç›´æ¥å¤„ç†PCMæ•°æ®è¿›è¡Œæ’­æ”¾ï¼ˆä¸éœ€è¦WAVå¤´éƒ¨ï¼‰
              await this.preprocessAudioChunk(pcmData, false); // falseè¡¨ç¤ºè¿™æ˜¯çº¯PCMæ•°æ®
          }
          
          // æ¨¡æ‹Ÿæµå¼æ’­æ”¾ï¼ˆåˆ†å—å¤„ç†å®Œæ•´éŸ³é¢‘æ•°æ®ï¼‰
          async simulateStreamingPlayback(audioData) {
              this.log('ğŸ­ å¼€å§‹æ¨¡æ‹Ÿæµå¼æ’­æ”¾ï¼ˆåˆ†å—å¤„ç†å®Œæ•´éŸ³é¢‘ï¼‰');
              
              // åˆ†æéŸ³é¢‘æ ¼å¼
              const audioArray = new Uint8Array(audioData);
              this.analyzeAudioFormat(audioArray);
              
              // ç¡®å®šéŸ³é¢‘æ•°æ®èµ·å§‹ä½ç½®
              let audioStart = 0;
              if (this.isWavFormat) {
                  audioStart = 44; // è·³è¿‡WAVå¤´éƒ¨
                  this.log('ğŸ“„ æ£€æµ‹åˆ°WAVæ ¼å¼ï¼Œè·³è¿‡44å­—èŠ‚å¤´éƒ¨');
              }
              
              // è®¡ç®—åˆ†å—å¤§å°ï¼ˆæ¨¡æ‹Ÿç½‘ç»œä¼ è¾“ï¼‰
              const chunkSize = 8192; // 8KB per chunkï¼Œæ¨¡æ‹Ÿç½‘ç»œä¼ è¾“å—å¤§å°
              const actualAudioData = audioArray.slice(audioStart);
              const totalChunks = Math.ceil(actualAudioData.length / chunkSize);
              
              this.log(`ğŸ“¦ å°†éŸ³é¢‘æ•°æ®åˆ†æˆ${totalChunks}å—è¿›è¡Œæ¨¡æ‹Ÿæµå¼æ’­æ”¾`);
              
              // é€å—å¤„ç†éŸ³é¢‘æ•°æ®
              for (let i = 0; i < totalChunks && this.isStreaming; i++) {
                  const start = i * chunkSize;
                  const end = Math.min(start + chunkSize, actualAudioData.length);
                  const chunk = actualAudioData.slice(start, end);
                  
                  // ä¸ºç¬¬ä¸€å—æ·»åŠ WAVå¤´éƒ¨
                  let chunkWithHeader;
                  if (i === 0 && this.isWavFormat) {
                      // åˆ›å»ºå®Œæ•´çš„WAVå¤´éƒ¨
                      const wavHeader = audioArray.slice(0, 44);
                      chunkWithHeader = new Uint8Array(44 + chunk.length);
                      chunkWithHeader.set(wavHeader, 0);
                      chunkWithHeader.set(chunk, 44);
                  } else {
                      chunkWithHeader = chunk;
                  }
                  
                  // ä¿å­˜åŸå§‹æ•°æ®ç”¨äºä¸‹è½½
                  this.audioChunks.push(new Uint8Array(chunkWithHeader));
                  this.totalBytes += chunkWithHeader.byteLength;
                  
                  // æ›´æ–°ç»Ÿè®¡
                  const currentTime = Date.now();
                  if (this.lastChunkTime > 0) {
                      const interval = currentTime - this.lastChunkTime;
                      this.chunkIntervals.push(interval);
                      if (this.chunkIntervals.length > 20) {
                          this.chunkIntervals.shift();
                      }
                      this.updateNetworkStats();
                  }
                  this.lastChunkTime = currentTime;
                  
                  this.log(`ğŸ“¥ æ¨¡æ‹Ÿæ¥æ”¶éŸ³é¢‘å— ${i + 1}/${totalChunks}: ${this.formatBytes(chunkWithHeader.byteLength)}`);
                  
                  // æ›´æ–°UI
                  this.updateBufferSize();
                  this.updateBufferProgress((i + 1) / totalChunks * 100);
                  
                  // å¤„ç†éŸ³é¢‘å—ç”¨äºæ’­æ”¾
                  if (i === 0 && this.isWavFormat) {
                      // ç¬¬ä¸€å—åŒ…å«å¤´éƒ¨ï¼Œç›´æ¥å¤„ç†PCMæ•°æ®éƒ¨åˆ†
                      await this.preprocessAudioChunk(chunk, false); // falseè¡¨ç¤ºè¿™æ˜¯çº¯PCMæ•°æ®
                  } else {
                      // åç»­å—éƒ½æ˜¯çº¯PCMæ•°æ®
                      await this.preprocessAudioChunk(chunkWithHeader, false);
                  }
                  
                  // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿï¼ˆæ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´ï¼‰
                  const delay = Math.max(50, 100 - (i * 2)); // å¼€å§‹æ—¶å»¶è¿Ÿè¾ƒå¤§ï¼Œåç»­é€æ¸å‡å°‘
                  await new Promise(resolve => setTimeout(resolve, delay));
              }
              
              this.log('âœ… æ¨¡æ‹Ÿæµå¼æ’­æ”¾æ•°æ®å¤„ç†å®Œæˆ');
              this.finishStreaming();
          }
          
          // æ·»åŠ éŸ³é¢‘æ•°æ®å—
          async addAudioChunk(chunk) {
              if (!this.isStreaming) return;
              
              const chunkArray = new Uint8Array(chunk);
              this.audioChunks.push(chunkArray); // ä¿å­˜åŸå§‹æ•°æ®ç”¨äºä¸‹è½½
              this.totalBytes += chunk.byteLength;
              
              const currentTime = Date.now();
              
              // ç½‘ç»œæŠ–åŠ¨æ£€æµ‹
              if (this.lastChunkTime > 0) {
                  const interval = currentTime - this.lastChunkTime;
                  this.chunkIntervals.push(interval);
                  
                  // ä¿æŒæœ€è¿‘20ä¸ªé—´éš”ç”¨äºç»Ÿè®¡
                  if (this.chunkIntervals.length > 20) {
                      this.chunkIntervals.shift();
                  }
                  
                  // è®¡ç®—ç½‘ç»œæŠ–åŠ¨
                  this.updateNetworkStats();
              }
              this.lastChunkTime = currentTime;
              
              this.log(`ğŸ“¥ æ¥æ”¶éŸ³é¢‘å—: ${this.formatBytes(chunk.byteLength)} (æ€»è®¡: ${this.formatBytes(this.totalBytes)}), é—´éš”: ${this.lastChunkTime > 0 ? (currentTime - this.lastChunkTime) : 0}ms`);
              
              // æ£€æŸ¥æ˜¯å¦æ˜¯ç¬¬ä¸€ä¸ªå—ï¼Œå¦‚æœæ˜¯ï¼Œåˆ†æéŸ³é¢‘æ ¼å¼
              if (this.audioChunks.length === 1) {
                  this.analyzeAudioFormat(chunkArray);
              }
              
              // æ›´æ–°UI
              this.updateBufferSize();
              this.updateBufferProgress();
              
              // ä½¿ç”¨Web Audio APIå¤„ç†éŸ³é¢‘å—
              await this.preprocessAudioChunk(chunkArray);
          }
          
          // åˆ†æéŸ³é¢‘æ ¼å¼
          analyzeAudioFormat(firstChunk) {
              try {
                  // æ£€æŸ¥æ˜¯å¦æ˜¯WAVæ ¼å¼ (RIFFå¤´)
                  const headerString = String.fromCharCode(...firstChunk.slice(0, 4));
                  if (headerString === 'RIFF') {
                      this.log('ğŸµ æ£€æµ‹åˆ°WAVæ ¼å¼éŸ³é¢‘');
                      this.isWavFormat = true;
                  } else {
                      this.log('ğŸµ æ£€æµ‹åˆ°PCMæ ¼å¼éŸ³é¢‘ï¼Œå°†è½¬æ¢ä¸ºWAV');
                      this.isWavFormat = false;
                  }
              } catch (error) {
                  this.log('âš ï¸ éŸ³é¢‘æ ¼å¼åˆ†æå¤±è´¥: ' + error.message);
                  this.isWavFormat = false; // é»˜è®¤å‡è®¾ä¸ºPCM
              }
          }
          
          // æ›´æ–°ç½‘ç»œç»Ÿè®¡ä¿¡æ¯
          updateNetworkStats() {
              if (this.chunkIntervals.length < 3) return;
              
              const avgInterval = this.chunkIntervals.reduce((a, b) => a + b, 0) / this.chunkIntervals.length;
              const variance = this.chunkIntervals.reduce((acc, val) => acc + Math.pow(val - avgInterval, 2), 0) / this.chunkIntervals.length;
              const jitter = Math.sqrt(variance);
              
              this.rtfStats.avgChunkInterval = avgInterval;
              this.rtfStats.networkJitter = jitter;
              
              // æ ¹æ®ç½‘ç»œçŠ¶å†µåŠ¨æ€è°ƒæ•´é¢„ç¼“å†²é˜ˆå€¼
              if (jitter > 150 && this.preBufferThreshold < 8) {
                  this.preBufferThreshold = Math.min(8, this.preBufferThreshold + 1);
                  this.log(`ç½‘ç»œæŠ–åŠ¨${jitter.toFixed(0)}msï¼Œå¢åŠ é¢„ç¼“å†²é˜ˆå€¼åˆ°${this.preBufferThreshold}`, 'warning');
              } else if (jitter < 30 && this.preBufferThreshold > 3) {
                  this.preBufferThreshold = Math.max(3, this.preBufferThreshold - 1);
                  this.log(`ç½‘ç»œç¨³å®š${jitter.toFixed(0)}msï¼Œé™ä½é¢„ç¼“å†²é˜ˆå€¼åˆ°${this.preBufferThreshold}`, 'info');
              }
          }
          
          // é¢„å¤„ç†éŸ³é¢‘å—å¹¶æ·»åŠ åˆ°é¢„ç¼“å†²é˜Ÿåˆ—
          async preprocessAudioChunk(audioData, hasWavHeader = null) {
              if (!this.audioContext) {
                  await this.initializeAudioContext();
              }
              
              try {
                  let rawAudioData;
                  
                  // å¤„ç†ä¸åŒæ ¼å¼çš„éŸ³é¢‘æ•°æ®
                  if (hasWavHeader === false) {
                      // æ˜ç¡®æŒ‡å®šè¿™æ˜¯çº¯PCMæ•°æ®
                      rawAudioData = audioData;
                  } else if (hasWavHeader === true || (hasWavHeader === null && this.isWavFormat)) {
                      // WAVæ ¼å¼ï¼Œè·³è¿‡44å­—èŠ‚å¤´éƒ¨
                      if (audioData.length <= 44) {
                          this.log('âš ï¸ WAVéŸ³é¢‘æ•°æ®å¤ªå°ï¼Œè·³è¿‡å¤„ç†', 'warning');
                          return;
                      }
                      rawAudioData = audioData.slice(44);
                  } else {
                      // PCMæ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
                      rawAudioData = audioData;
                  }
                  
                  // è§£ç PCMæ•°æ®
                  const sampleRate = sampleRate1; // CosyVoiceè¾“å‡ºé‡‡æ ·ç‡
                  const numChannels = 1;
                  const numSamples = rawAudioData.length / 2; // 16-bit = 2 bytes per sample
                  
                  if (numSamples === 0) {
                      this.log('âš ï¸ æ”¶åˆ°ç©ºéŸ³é¢‘å—ï¼Œè·³è¿‡å¤„ç†', 'warning');
                      return;
                  }
                  
                  // åˆ›å»ºAudioBuffer
                  const audioBuffer = this.audioContext.createBuffer(numChannels, numSamples, sampleRate);
                  const channelData = audioBuffer.getChannelData(0);
                  
                  // è½¬æ¢16-bit PCMä¸ºfloat32 - æ”¹è¿›å­—èŠ‚åºå¤„ç†ç¡®ä¿è·¨å¹³å°å…¼å®¹æ€§
                  const dataView = new DataView(rawAudioData.buffer, rawAudioData.byteOffset, rawAudioData.byteLength);
                  
                  // æ£€æµ‹å¹¶ä½¿ç”¨æ­£ç¡®çš„å­—èŠ‚åºï¼ˆæœåŠ¡ç«¯é€šå¸¸ä½¿ç”¨å°ç«¯åºè¾“å‡ºPCMï¼‰
                  const littleEndian = true; // CosyVoiceæœåŠ¡ç«¯è¾“å‡ºä¸ºå°ç«¯åºPCM
                  
                  for (let i = 0; i < numSamples; i++) {
                      // ä½¿ç”¨32768.0è€Œä¸æ˜¯32767è¿›è¡Œå½’ä¸€åŒ–ä»¥é¿å…è½»å¾®çš„å‰Šå³°
                      const sample = dataView.getInt16(i * 2, littleEndian) / 32768.0;
                      
                      // ç¡®ä¿æ ·æœ¬å€¼åœ¨æœ‰æ•ˆèŒƒå›´å†…ï¼Œé˜²æ­¢å¼‚å¸¸å€¼
                      channelData[i] = Math.max(-1.0, Math.min(1.0, sample));
                  }
                  
                  // æ·»åŠ åˆ°é¢„ç¼“å†²é˜Ÿåˆ—
                  this.audioPreBuffer.push({
                      buffer: audioBuffer,
                      duration: audioBuffer.duration,
                      timestamp: Date.now()
                  });
                  
                  this.rtfStats.chunksReceived++;
                  this.rtfStats.totalAudioDuration += audioBuffer.duration;
                  
                  this.log(`ğŸµ é¢„å¤„ç†éŸ³é¢‘å—: ${numSamples}æ ·æœ¬, æ—¶é•¿${audioBuffer.duration.toFixed(3)}s, é˜Ÿåˆ—${this.audioPreBuffer.length}å—`);
                  
                  // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹æ’­æ”¾
                  if (!this.playStarted && this.audioPreBuffer.length >= this.preBufferThreshold) {
                      this.startStreamPlayback();
                  }
                  
              } catch (error) {
                  this.log(`âŒ é¢„å¤„ç†éŸ³é¢‘å—å‡ºé”™: ${error.message}`, 'error');
              }
          }
          
          // å¼€å§‹æµå¼æ’­æ”¾
          startStreamPlayback() {
              if (this.playStarted || this.audioPreBuffer.length === 0) {
                  return;
              }
              
              this.playStarted = true;
              this.rtfStats.startTime = Date.now();
              this.isPrebuffering = false;
              
              this.log(`ğŸ‰ å¼€å§‹æµå¼æ’­æ”¾ï¼Œé¢„ç¼“å†²${this.audioPreBuffer.length}å—éŸ³é¢‘`);
              
              // å¯åŠ¨æ’­æ”¾æ—¶é—´æ›´æ–°å™¨
              this.startTimeUpdater();
              
              // æ›´æ–°æŒ‰é’®çŠ¶æ€
              this.updateStreamButtons();
              
              // ç«‹å³è°ƒåº¦å‰å‡ ä¸ªéŸ³é¢‘å—ï¼Œç¡®ä¿å¹³æ»‘å¼€å§‹
              this.scheduleNextAudio();
              setTimeout(() => this.scheduleNextAudio(), 20);
              setTimeout(() => this.scheduleNextAudio(), 40);
              
              // å¯åŠ¨æ™ºèƒ½è°ƒåº¦å™¨
              if (this.audioScheduler) {
                  clearInterval(this.audioScheduler);
              }
              
              // æ ¹æ®ç½‘ç»œçŠ¶å†µåŠ¨æ€è°ƒæ•´è°ƒåº¦é¢‘ç‡
              let schedulerInterval = 30; // åŸºç¡€30msé—´éš”
              if (this.rtfStats.networkJitter > 100) {
                  schedulerInterval = 20; // ç½‘ç»œä¸ç¨³å®šæ—¶æ›´é¢‘ç¹æ£€æŸ¥
              }
              
              this.audioScheduler = setInterval(() => {
                  this.scheduleNextAudio();
                  
                  // åŠ¨æ€è°ƒæ•´è°ƒåº¦é¢‘ç‡
                  if (this.audioPreBuffer.length > 5) {
                      // ç¼“å†²å……è¶³æ—¶é™ä½æ£€æŸ¥é¢‘ç‡
                      clearInterval(this.audioScheduler);
                      this.audioScheduler = setInterval(() => this.scheduleNextAudio(), 50);
                  } else if (this.audioPreBuffer.length < 2) {
                      // ç¼“å†²ä¸è¶³æ—¶æé«˜æ£€æŸ¥é¢‘ç‡
                      clearInterval(this.audioScheduler);
                      this.audioScheduler = setInterval(() => this.scheduleNextAudio(), 20);
                  }
              }, schedulerInterval);
          }
          
          // å¯åŠ¨æ’­æ”¾æ—¶é—´æ›´æ–°å™¨
          startTimeUpdater() {
              if (this.timeUpdater) {
                  clearInterval(this.timeUpdater);
              }
              
              this.timeUpdater = setInterval(() => {
                  this.updatePlayTime();
              }, 1000); // æ¯ç§’æ›´æ–°ä¸€æ¬¡æ’­æ”¾æ—¶é—´
          }
          
          // åœæ­¢æ’­æ”¾æ—¶é—´æ›´æ–°å™¨
          stopTimeUpdater() {
              if (this.timeUpdater) {
                  clearInterval(this.timeUpdater);
                  this.timeUpdater = null;
              }
          }
          
          // è°ƒåº¦ä¸‹ä¸€ä¸ªéŸ³é¢‘å—æ’­æ”¾
          scheduleNextAudio() {
              if (this.audioPreBuffer.length === 0) {
                  return;
              }
              
              const currentTime = this.audioContext.currentTime;
              
              // åŠ¨æ€è°ƒæ•´é¢„åˆ¤æ—¶é—´ï¼Œæ ¹æ®ç½‘ç»œæŠ–åŠ¨æƒ…å†µ
              let lookahead = 0.1; // åŸºç¡€100msé¢„åˆ¤æ—¶é—´
              if (this.rtfStats.networkJitter > 100) {
                  lookahead = Math.min(0.3, 0.1 + this.rtfStats.networkJitter / 1000); // ç½‘ç»œä¸ç¨³å®šæ—¶å¢åŠ é¢„åˆ¤æ—¶é—´
              }
              
              // å¦‚æœä¸‹ä¸€ä¸ªæ’­æ”¾æ—¶é—´å¤ªè¿œï¼Œæš‚æ—¶ä¸è°ƒåº¦
              if (this.nextPlayTime > currentTime + lookahead) {
                  return;
              }
              
              // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´å¤šç¼“å†²ï¼ˆé˜²æ­¢åœé¡¿ï¼‰
              const bufferTime = (this.nextPlayTime - currentTime) * 1000;
              const minBufferTime = 50;  // æœ€å°ç¼“å†²æ—¶é—´
              const minBufferBlocks = 2; // æœ€å°ç¼“å†²å—æ•°
              
              if (bufferTime < minBufferTime && this.audioPreBuffer.length < minBufferBlocks) {
                  this.log(`ç¼“å†²ä¸è¶³(${bufferTime.toFixed(0)}ms, ${this.audioPreBuffer.length}å—)ï¼Œæš‚ç¼“è°ƒåº¦`, 'warning');
                  return;
              }
              
              const audioChunk = this.audioPreBuffer.shift();
              if (!audioChunk) {
                  return;
              }
              
              try {
                  // åˆ›å»ºéŸ³é¢‘æº
                  const source = this.audioContext.createBufferSource();
                  source.buffer = audioChunk.buffer;
                  source.connect(this.audioContext.destination);
                  
                  // è®¡ç®—æ’­æ”¾æ—¶é—´ï¼Œç¡®ä¿å¹³æ»‘è¡”æ¥
                  const playTime = Math.max(currentTime + 0.005, this.nextPlayTime); // æœ€å°‘5msé—´éš”é¿å…é‡å 
                  
                  // è®¾ç½®æ’­æ”¾å®Œæˆå›è°ƒ
                  source.addEventListener('ended', () => {
                      this.rtfStats.chunksPlayed++;
                      this.updateRTFStats();
                  });
                  
                  // é”™è¯¯å¤„ç†
                  source.addEventListener('error', (e) => {
                      this.log(`âŒ éŸ³é¢‘æ’­æ”¾é”™è¯¯: ${e.message}`, 'error');
                      // å°è¯•é‡æ–°è°ƒåº¦ä¸‹ä¸€ä¸ªéŸ³é¢‘å—
                      setTimeout(() => this.scheduleNextAudio(), 10);
                  });
                  
                  // å¼€å§‹æ’­æ”¾
                  source.start(playTime);
                  this.nextPlayTime = playTime + audioChunk.duration;
                  
                  if (!this.isPlaying) {
                      this.isPlaying = true;
                      this.playbackStarted = true;
                      this.updateStatus('æ’­æ”¾ä¸­', 'playStatus');
                      this.updateStatus('æ’­æ”¾ä¸­', 'bufferStatus');
                      this.updateStreamButtons(); // æ›´æ–°æŒ‰é’®çŠ¶æ€
                      this.log('ğŸµ æµå¼æ’­æ”¾å·²å¼€å§‹');
                  }
                  
                  // ä¼˜åŒ–æ—¥å¿—è¾“å‡ºï¼Œå‡å°‘é¢‘ç¹æ—¥å¿—
                  if (this.rtfStats.chunksPlayed % 3 === 0) {
                      this.log(`â–¶ï¸ æ’­æ”¾éŸ³é¢‘å—: æ—¶é•¿${audioChunk.duration.toFixed(3)}s, ç¼“å†²${this.audioPreBuffer.length}å—`);
                  }
                  
              } catch (error) {
                  this.log(`âŒ æ’­æ”¾éŸ³é¢‘å—å‡ºé”™: ${error.message}`, 'error');
                  // å°è¯•é‡æ–°è°ƒåº¦
                  setTimeout(() => this.scheduleNextAudio(), 50);
              }
          }
          
          // æ›´æ–°RTFç»Ÿè®¡ä¿¡æ¯
          updateRTFStats() {
              if (!this.rtfStats.startTime) return;
              
              const elapsed = (Date.now() - this.rtfStats.startTime) / 1000;
              const rtf = elapsed / this.rtfStats.totalAudioDuration;
              
              // RTFæ€§èƒ½è­¦å‘Šå’Œå»ºè®®ï¼ˆä¼˜åŒ–æ˜¾ç¤ºé¢‘ç‡ï¼‰
              if (rtf > 1.5 && this.rtfStats.chunksPlayed % 10 === 0) {
                  this.log(`âš ï¸ RTFä¸¥é‡è¿‡é«˜: ${rtf.toFixed(2)}, ç½‘ç»œæŠ–åŠ¨: ${this.rtfStats.networkJitter.toFixed(0)}ms`, 'error');
              } else if (rtf > 1.2 && this.rtfStats.chunksPlayed % 8 === 0) {
                  this.log(`âš ï¸ RTFåé«˜: ${rtf.toFixed(2)}, å·²è‡ªåŠ¨è°ƒæ•´é¢„ç¼“å†²é˜ˆå€¼åˆ°${this.preBufferThreshold}`, 'warning');
              } else if (this.rtfStats.chunksPlayed % 15 === 0) {
                  // æ¯15å—æ˜¾ç¤ºä¸€æ¬¡è¯¦ç»†ç»Ÿè®¡
                  this.log(`ğŸ“Š RTF: ${rtf.toFixed(2)}, æŠ–åŠ¨: ${this.rtfStats.networkJitter.toFixed(0)}ms, å¹³å‡é—´éš”: ${this.rtfStats.avgChunkInterval.toFixed(0)}ms`);
              }
              
              // æ€§èƒ½ä¼˜åŒ–å»ºè®®
              if (this.rtfStats.chunksPlayed % 30 === 0) {
                  if (this.rtfStats.networkJitter > 300) {
                      this.log('âš ï¸ ç½‘ç»œä¸¥é‡ä¸ç¨³å®šï¼Œå»ºè®®æ£€æŸ¥ç½‘ç»œè¿æ¥', 'error');
                  } else if (this.rtfStats.networkJitter < 30 && this.preBufferThreshold > 4) {
                      this.log('âœ… ç½‘ç»œéå¸¸ç¨³å®šï¼Œå¯ä»¥è€ƒè™‘é™ä½é¢„ç¼“å†²é˜ˆå€¼ä»¥å‡å°‘å»¶è¿Ÿ');
                  }
              }
          }
          

          
          // åˆå¹¶æ‰€æœ‰éŸ³é¢‘å—
          combineAudioChunks() {
              const totalSize = this.audioChunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
              const combined = new Uint8Array(totalSize);
              let offset = 0;
              
              for (const chunk of this.audioChunks) {
                  combined.set(chunk, offset);
                  offset += chunk.byteLength;
              }
              
              // å¦‚æœä¸æ˜¯WAVæ ¼å¼ï¼Œè½¬æ¢ä¸ºWAV
              if (!this.isWavFormat && combined.length > 0) {
                  this.log('ğŸ”„ å°†PCMæ•°æ®è½¬æ¢ä¸ºWAVæ ¼å¼');
                  return this.pcmToWav(combined);
              }
              
              return combined;
          }
          
          // å°†PCMæ•°æ®è½¬æ¢ä¸ºWAVæ ¼å¼ - æ”¹è¿›å­—èŠ‚åºå¤„ç†
          pcmToWav(pcmData, sampleRate = 16000, channels = 1, bitsPerSample = 16) {
              sampleRate = sampleRate1;
              const length = pcmData.length / 2; // 16ä½PCM
              const arrayBuffer = new ArrayBuffer(44 + pcmData.length);
              const view = new DataView(arrayBuffer);
              
              // WAVæ–‡ä»¶å¤´ï¼ˆä½¿ç”¨å°ç«¯åºï¼ŒWAVæ ‡å‡†æ ¼å¼ï¼‰
              const writeString = (offset, string) => {
                  for (let i = 0; i < string.length; i++) {
                      view.setUint8(offset + i, string.charCodeAt(i));
                  }
              };
              
              const littleEndian = true; // WAVæ ¼å¼æ ‡å‡†è¦æ±‚å°ç«¯åº
              
              writeString(0, 'RIFF');
              view.setUint32(4, 36 + pcmData.length, littleEndian);
              writeString(8, 'WAVE');
              writeString(12, 'fmt ');
              view.setUint32(16, 16, littleEndian);
              view.setUint16(20, 1, littleEndian);  // PCM format
              view.setUint16(22, channels, littleEndian);
              view.setUint32(24, sampleRate, littleEndian);
              view.setUint32(28, sampleRate * channels * bitsPerSample / 8, littleEndian);
              view.setUint16(32, channels * bitsPerSample / 8, littleEndian);
              view.setUint16(34, bitsPerSample, littleEndian);
              writeString(36, 'data');
              view.setUint32(40, pcmData.length, littleEndian);
              
              // å¤åˆ¶PCMæ•°æ®ï¼ˆç¡®ä¿æ•°æ®å®Œæ•´æ€§ï¼‰
              const targetArray = new Uint8Array(arrayBuffer, 44);
              targetArray.set(pcmData);
              
              return new Uint8Array(arrayBuffer);
          }
          
          // ç®€åŒ–çš„è‡ªåŠ¨æ’­æ”¾ï¼ˆä¸»è¦ç”¨äºWeb Audio APIçš„éŸ³é¢‘ä¸Šä¸‹æ–‡æ¢å¤ï¼‰
          async startAutoPlay() {
              // ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„äºè¿è¡ŒçŠ¶æ€
              if (this.audioContext && this.audioContext.state === 'suspended') {
                  try {
                      await this.audioContext.resume();
                      this.log('ğŸ”Š éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤ï¼Œå¯ä»¥è¿›è¡Œæµå¼æ’­æ”¾');
                  } catch (error) {
                      this.log('âŒ æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡å¤±è´¥: ' + error.message);
                      this.showClickToPlayHint();
                  }
              }
              
              // å¦‚æœæœ‰é¢„ç¼“å†²çš„éŸ³é¢‘ä½†è¿˜æ²¡å¼€å§‹æ’­æ”¾ï¼Œå°è¯•å¼€å§‹
              if (!this.playStarted && this.audioPreBuffer.length >= this.preBufferThreshold) {
                  this.startStreamPlayback();
              }
          }
          
          // æ˜¾ç¤ºç‚¹å‡»æ’­æ”¾æç¤º
          showClickToPlayHint() {
              // ç§»é™¤æ—§çš„æç¤º
              const oldHint = document.getElementById('clickHint');
              if (oldHint) oldHint.remove();
              
              const hint = document.createElement('div');
              hint.id = 'clickHint';
              hint.style.cssText = `
                  background: #ff9800;
                  color: white;
                  padding: 12px;
                  border-radius: 8px;
                  text-align: center;
                  margin: 10px 0;
                  cursor: pointer;
                  animation: pulse 2s infinite;
                  box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
              `;
              hint.innerHTML = 'ğŸµ ç‚¹å‡»æ­¤å¤„å¯ç”¨éŸ³é¢‘æ’­æ”¾ï¼ˆè§£é™¤æµè§ˆå™¨é™åˆ¶ï¼‰';
              hint.onclick = async () => {
                  try {
                      // å¯ç”¨éŸ³é¢‘ä¸Šä¸‹æ–‡
                      if (this.audioContext && this.audioContext.state === 'suspended') {
                          await this.audioContext.resume();
                          this.log('ğŸ”Š ç”¨æˆ·ç‚¹å‡»å¯ç”¨éŸ³é¢‘æ’­æ”¾æˆåŠŸ');
                      }
                      
                      // å°è¯•æ’­æ”¾HTML5éŸ³é¢‘ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                      if (this.audioElement.src) {
                          this.audioElement.play().catch(() => {
                              this.log('ğŸ“» HTML5éŸ³é¢‘æ’­æ”¾å°è¯•ï¼ˆå¯èƒ½æ²¡æœ‰éŸ³é¢‘æºï¼‰');
                          });
                      }
                      
                      // å¦‚æœæœ‰é¢„ç¼“å†²çš„æµå¼éŸ³é¢‘ï¼Œå¼€å§‹æ’­æ”¾
                      if (!this.playStarted && this.audioPreBuffer.length >= this.preBufferThreshold) {
                          this.startStreamPlayback();
                      }
                      
                      this.updateStreamButtons();
                      hint.remove();
                      
                  } catch (error) {
                      this.log('âŒ å¯ç”¨éŸ³é¢‘æ’­æ”¾å¤±è´¥: ' + error.message);
                  }
              };
              
              const streamStatus = document.getElementById('streamStatus');
              if (streamStatus) {
                  streamStatus.insertBefore(hint, streamStatus.firstChild);
              }
          }
          
          // å®Œæˆæµå¼æ¥æ”¶
          finishStreaming() {
              this.isStreaming = false;
              this.log('âœ… æµå¼æ¥æ”¶å®Œæˆ');
              
              if (this.totalBytes > 0) {
                  this.updateStatus('æ¥æ”¶å®Œæˆ', 'bufferStatus');
                  this.updateBufferProgress(100);
                  
                  // å¦‚æœè¿˜æ²¡å¼€å§‹æ’­æ”¾ï¼Œç°åœ¨å¼€å§‹
                  if (!this.playStarted) {
                      if (this.audioPreBuffer.length > 0) {
                          this.startStreamPlayback();
                      } else {
                          this.log('âš ï¸ æ²¡æœ‰ç¼“å†²çš„éŸ³é¢‘æ•°æ®å¯æ’­æ”¾');
                      }
                  } else {
                      // æµå¼æ’­æ”¾å·²ç»å¼€å§‹ï¼Œç­‰å¾…ç¼“å†²éŸ³é¢‘æ’­æ”¾å®Œæˆ
                      this.waitForStreamingComplete();
                  }
                  
                  // åˆå¹¶éŸ³é¢‘æ•°æ®ä¾›ä¸‹è½½
                  this.prepareDownloadAudio();
              } else {
                  this.log('âš ï¸ æ²¡æœ‰æ¥æ”¶åˆ°éŸ³é¢‘æ•°æ®');
              }
          }
          
          // ç­‰å¾…æµå¼æ’­æ”¾å®Œæˆ
          waitForStreamingComplete() {
              this.log(`ğŸ“Š TTSç”Ÿæˆå®Œæˆï¼Œç­‰å¾…ç¼“å†²éŸ³é¢‘æ’­æ”¾å®Œæ¯•(å‰©ä½™${this.audioPreBuffer.length}å—)`);
              
              // åœæ­¢è°ƒåº¦å™¨ï¼Œä½†ä¿æŒæ’­æ”¾çŠ¶æ€
              if (this.audioScheduler) {
                  clearInterval(this.audioScheduler);
                  this.audioScheduler = null;
              }
              
              // æ’­æ”¾å‰©ä½™çš„é¢„ç¼“å†²éŸ³é¢‘
              const playRemainingAudio = () => {
                  if (this.audioPreBuffer.length > 0) {
                      const remaining = this.audioPreBuffer.length;
                      this.log(`ğŸµ æ’­æ”¾å‰©ä½™${remaining}å—ç¼“å†²éŸ³é¢‘`);
                      
                      // è°ƒåº¦å‰©ä½™éŸ³é¢‘
                      const remainingScheduler = setInterval(() => {
                          if (this.audioPreBuffer.length === 0) {
                              clearInterval(remainingScheduler);
                              this.completeStreamPlayback();
                          } else {
                              this.scheduleNextAudio();
                          }
                      }, 50);
                  } else {
                      this.completeStreamPlayback();
                  }
              };
              
              playRemainingAudio();
          }
          
          // å®Œæˆæµå¼æ’­æ”¾
          completeStreamPlayback() {
              this.log('ğŸ‰ æµå¼æ’­æ”¾å®Œå…¨å®Œæˆ');
              
              // ç­‰å¾…ä¸€æ®µæ—¶é—´ç¡®ä¿æœ€åçš„éŸ³é¢‘æ’­æ”¾å®Œæˆ
              setTimeout(() => {
                  this.isPlaying = false;
                  this.playStarted = false;
                  this.stopTimeUpdater(); // åœæ­¢æ—¶é—´æ›´æ–°å™¨
                  
                  if (this.audioContext) {
                      // ä¿æŒéŸ³é¢‘ä¸Šä¸‹æ–‡æ´»è·ƒï¼Œä»¥ä¾¿åç»­ä½¿ç”¨
                      this.audioContext.resume().catch(() => {});
                  }
                  
                  this.updateStatus('æ’­æ”¾å®Œæˆ', 'playStatus');
                  this.updateStreamButtons(); // æ›´æ–°æŒ‰é’®çŠ¶æ€
                  
                  // æ˜¾ç¤ºæœ€ç»ˆç»Ÿè®¡
                  const finalRTF = this.rtfStats.startTime ? 
                      ((Date.now() - this.rtfStats.startTime) / 1000) / this.rtfStats.totalAudioDuration : 0;
                  this.log(`ğŸ“Š æœ€ç»ˆç»Ÿè®¡ - RTF: ${finalRTF.toFixed(2)}, å·²æ’­æ”¾${this.rtfStats.chunksPlayed}/${this.rtfStats.chunksReceived}å—`);
                  
                  // é‡ç½®ç»Ÿè®¡æ•°æ®
                  this.rtfStats = {
                      chunksReceived: 0,
                      chunksPlayed: 0,
                      totalAudioDuration: 0,
                      startTime: null,
                      networkJitter: 0,
                      avgChunkInterval: 0
                  };
              }, 1000);
          }
          
          // å‡†å¤‡ä¸‹è½½éŸ³é¢‘
          prepareDownloadAudio() {
              if (this.audioChunks.length === 0) {
                  this.log('âš ï¸ æ²¡æœ‰éŸ³é¢‘æ•°æ®å¯åˆæˆ');
                  return;
              }
              
              try {
                  let combinedAudio;
                  
                  // æ£€æŸ¥ç¬¬ä¸€ä¸ªå—æ˜¯å¦åŒ…å«WAVå¤´éƒ¨
                  const firstChunk = this.audioChunks[0];
                  const headerString = String.fromCharCode(...firstChunk.slice(0, 4));
                  
                  if (headerString === 'RIFF') {
                      // å·²ç»æ˜¯WAVæ ¼å¼ï¼Œç›´æ¥åˆå¹¶
                      this.log('ğŸ“„ æ£€æµ‹åˆ°WAVæ ¼å¼æ•°æ®ï¼Œç›´æ¥åˆå¹¶');
                      combinedAudio = this.combineAudioChunks();
                  } else {
                      // æ˜¯PCMæ ¼å¼ï¼Œéœ€è¦æ·»åŠ WAVå¤´éƒ¨
                      this.log('ğŸ”„ æ£€æµ‹åˆ°PCMæ ¼å¼æ•°æ®ï¼Œæ·»åŠ WAVå¤´éƒ¨');
                      
                      // åˆå¹¶æ‰€æœ‰PCMæ•°æ®
                      const totalSize = this.audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
                      const combinedPCM = new Uint8Array(totalSize);
                      let offset = 0;
                      
                      for (const chunk of this.audioChunks) {
                          combinedPCM.set(chunk, offset);
                          offset += chunk.length;
                      }
                      
                      // è½¬æ¢ä¸ºWAVæ ¼å¼
                      combinedAudio = this.pcmToWav(combinedPCM);
                      this.log(`ğŸµ PCMè½¬WAVå®Œæˆ: ${this.formatBytes(combinedPCM.length)} â†’ ${this.formatBytes(combinedAudio.length)}`);
                  }
                  
                  // åˆ›å»ºéŸ³é¢‘Blobä¾›ä¸‹è½½
                  const audioBlob = new Blob([combinedAudio], { type: 'audio/wav' });
                  const audioUrl = URL.createObjectURL(audioBlob);
                  
                  const audioPlayer = document.getElementById('audioPlayer');
                  const downloadLink = document.getElementById('downloadLink');
                  
                  audioPlayer.src = audioUrl;
                  downloadLink.href = audioUrl;
                  
                  document.getElementById('audioContainer').style.display = 'block';
                  this.log(`ğŸ“¥ å®Œæ•´éŸ³é¢‘å·²å‡†å¤‡å¥½ä¸‹è½½ (${this.formatBytes(combinedAudio.length)})`);
                  
              } catch (error) {
                  this.log(`âŒ å‡†å¤‡ä¸‹è½½éŸ³é¢‘å¤±è´¥: ${error.message}`, 'error');
              }
          }
          

          
          reset() {
              // åœæ­¢æµå¼æ’­æ”¾è°ƒåº¦å™¨å’Œæ—¶é—´æ›´æ–°å™¨
              if (this.audioScheduler) {
                  clearInterval(this.audioScheduler);
                  this.audioScheduler = null;
              }
              this.stopTimeUpdater();
              
              // é‡ç½®æ‰€æœ‰çŠ¶æ€
              this.audioChunks = [];
              this.audioPreBuffer = [];
              this.pendingChunks = [];
              this.totalBytes = 0;
              this.playedBytes = 0;
              this.isStreaming = false;
              this.isPlaying = false;
              this.isPrebuffering = true;
              this.playbackStarted = false;
              this.playStarted = false;
              this.nextPlayTime = 0;
              this.startTime = null;
              this.isWavFormat = true;
              this.lastChunkTime = 0;
              this.chunkIntervals = [];
              this.preBufferThreshold = 2;
              
              // é‡ç½®RTFç»Ÿè®¡
              this.rtfStats = {
                  chunksReceived: 0,
                  chunksPlayed: 0,
                  totalAudioDuration: 0,
                  startTime: null,
                  networkJitter: 0,
                  avgChunkInterval: 0
              };
              
              // æ¸…ç†æ—§çš„éŸ³é¢‘URL
              if (this.audioElement.src && this.audioElement.src.startsWith('blob:')) {
                  URL.revokeObjectURL(this.audioElement.src);
              }
              this.audioElement.src = '';
              
              // ç§»é™¤ç‚¹å‡»æç¤º
              const hint = document.getElementById('clickHint');
              if (hint) hint.remove();
              
              this.updateStatus('å‡†å¤‡ä¸­', 'bufferStatus');
              this.updateStatus('æœªæ’­æ”¾', 'playStatus');
              this.updateBufferProgress(0);
              this.updateBufferSize();
              this.updatePlayTime();
              this.updateStreamButtons(); // æ›´æ–°æŒ‰é’®çŠ¶æ€
              
              this.log('ğŸ”„ æ’­æ”¾å™¨å·²é‡ç½®');
          }
          
          stop() {
              this.isStreaming = false;
              this.isPlaying = false;
              
              // åœæ­¢è°ƒåº¦å™¨å’Œæ—¶é—´æ›´æ–°å™¨
              if (this.audioScheduler) {
                  clearInterval(this.audioScheduler);
                  this.audioScheduler = null;
              }
              this.stopTimeUpdater();
              
              // æš‚åœéŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆèŠ‚çœèµ„æºï¼‰
              if (this.audioContext && this.audioContext.state === 'running') {
                  this.audioContext.suspend().catch(() => {});
              }
              
              // æ¸…ç©ºé¢„ç¼“å†²é˜Ÿåˆ—
              this.audioPreBuffer = [];
              this.playStarted = false;
              this.nextPlayTime = 0;
              
              // åœæ­¢HTML5éŸ³é¢‘æ’­æ”¾
              if (this.audioElement.src) {
                  this.audioElement.pause();
                  this.audioElement.currentTime = 0;
              }
              
              this.updateStatus('å·²åœæ­¢', 'playStatus');
              this.updateStreamButtons();
              this.log('â¹ï¸ åœæ­¢æµå¼æ’­æ”¾');
          }
          
          // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆç”¨äºè§£å†³æµè§ˆå™¨è‡ªåŠ¨æ’­æ”¾é™åˆ¶ï¼‰
          async resumeAudioContext() {
              if (this.audioContext && this.audioContext.state === 'suspended') {
                  try {
                      await this.audioContext.resume();
                      this.log('ğŸ”Š éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤ï¼Œå¯ä»¥è¿›è¡Œæ’­æ”¾');
                      this.updateStreamButtons();
                      
                      // å¦‚æœæœ‰é¢„ç¼“å†²çš„éŸ³é¢‘ä¸”è¿˜æ²¡å¼€å§‹æ’­æ”¾ï¼Œå°è¯•å¼€å§‹
                      if (!this.playStarted && this.audioPreBuffer.length >= this.preBufferThreshold) {
                          this.startStreamPlayback();
                      }
                  } catch (error) {
                      this.log('âŒ æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡å¤±è´¥: ' + error.message);
                  }
              } else {
                  this.log('â„¹ï¸ éŸ³é¢‘ä¸Šä¸‹æ–‡å·²ç»å¤„äºè¿è¡ŒçŠ¶æ€');
              }
          }
          
          // æ›´æ–°æµå¼æ’­æ”¾æŒ‰é’®çŠ¶æ€
          updateStreamButtons() {
              const stopBtn = document.getElementById('stopStreamBtn');
              const resumeBtn = document.getElementById('resumeStreamBtn');
              
              if (stopBtn) {
                  stopBtn.style.display = (this.isStreaming || this.isPlaying) ? 'inline-block' : 'none';
              }
              
              if (resumeBtn) {
                  const needResume = this.audioContext && this.audioContext.state === 'suspended';
                  resumeBtn.style.display = needResume ? 'inline-block' : 'none';
              }
          }
          
          // UI æ›´æ–°æ–¹æ³•
          updateStatus(status, elementId) {
              const element = document.getElementById(elementId);
              if (element) {
                  element.textContent = status;
              }
          }
          
          updateBufferSize() {
              const element = document.getElementById('bufferSize');
              if (element) {
                  element.textContent = this.formatBytes(this.totalBytes);
              }
          }
          
          updateBufferProgress(percentage = null) {
              const element = document.getElementById('bufferFill');
              if (element) {
                  if (percentage !== null) {
                      element.style.width = percentage + '%';
                  } else if (this.totalBytes > 0) {
                      const progress = Math.min((this.totalBytes / this.maxBufferSize) * 100, 100);
                      element.style.width = progress + '%';
                  }
              }
          }
          
          updatePlayTime() {
              const element = document.getElementById('playTime');
              if (element) {
                  if (this.isPlaying && this.rtfStats.startTime) {
                      // ä½¿ç”¨æµå¼æ’­æ”¾çš„å®é™…æ’­æ”¾æ—¶é—´
                      const elapsed = (Date.now() - this.rtfStats.startTime) / 1000;
                      const minutes = Math.floor(elapsed / 60);
                      const seconds = Math.floor(elapsed % 60);
                      element.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                  } else if (this.audioElement.currentTime) {
                      // ä½¿ç”¨HTML5éŸ³é¢‘çš„æ’­æ”¾æ—¶é—´ï¼ˆç”¨äºä¸‹è½½éŸ³é¢‘ï¼‰
                      const minutes = Math.floor(this.audioElement.currentTime / 60);
                      const seconds = Math.floor(this.audioElement.currentTime % 60);
                      element.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                  } else {
                      element.textContent = '00:00';
                  }
              }
          }
          
          log(message) {
              const logContainer = document.getElementById('streamLog');
              if (logContainer) {
                  const logEntry = document.createElement('div');
                  logEntry.innerHTML = `<span style="color: #666">[${new Date().toLocaleTimeString()}]</span> ${message}`;
                  logContainer.appendChild(logEntry);
                  logContainer.scrollTop = logContainer.scrollHeight;
                  
                  // é™åˆ¶æ—¥å¿—æ¡æ•°
                  while (logContainer.children.length > 50) {
                      logContainer.removeChild(logContainer.firstChild);
                  }
              }
              console.log(message);
          }
          
          formatBytes(bytes) {
              if (bytes === 0) return '0 B';
              const k = 1024;
              const sizes = ['B', 'KB', 'MB'];
              const i = Math.floor(Math.log(bytes) / Math.log(k));
              return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
          }
      }
      
      // åˆ›å»ºæµå¼æ’­æ”¾å™¨å®ä¾‹
      const streamPlayer = new StreamingAudioPlayer();
      
      // è¯­é€Ÿæ»‘å—äº‹ä»¶
      document.getElementById('speed').addEventListener('input', function() {
          document.getElementById('speedValue').textContent = this.value + 'x';
      });

      // å°†PCMæ•°æ®è½¬æ¢ä¸ºWAVæ ¼å¼ - æ”¹è¿›å­—èŠ‚åºå¤„ç†
      function pcmToWav(pcmData, sampleRate = 24000, channels = 1, bitsPerSample = 16) {
          sampleRate = sampleRate1;
          const length = pcmData.length;
          const arrayBuffer = new ArrayBuffer(44 + length * 2);
          const view = new DataView(arrayBuffer);
          
          // WAVæ–‡ä»¶å¤´ï¼ˆä½¿ç”¨å°ç«¯åºï¼ŒWAVæ ‡å‡†æ ¼å¼ï¼‰
          const writeString = (offset, string) => {
              for (let i = 0; i < string.length; i++) {
                  view.setUint8(offset + i, string.charCodeAt(i));
              }
          };
          
          const littleEndian = true; // WAVæ ¼å¼æ ‡å‡†è¦æ±‚å°ç«¯åº
          
          writeString(0, 'RIFF');
          view.setUint32(4, 36 + length * 2, littleEndian);
          writeString(8, 'WAVE');
          writeString(12, 'fmt ');
          view.setUint32(16, 16, littleEndian);
          view.setUint16(20, 1, littleEndian);  // PCM format
          view.setUint16(22, channels, littleEndian);
          view.setUint32(24, sampleRate, littleEndian);
          view.setUint32(28, sampleRate * channels * bitsPerSample / 8, littleEndian);
          view.setUint16(32, channels * bitsPerSample / 8, littleEndian);
          view.setUint16(34, bitsPerSample, littleEndian);
          writeString(36, 'data');
          view.setUint32(40, length * 2, littleEndian);
          
          // PCMæ•°æ®å¤„ç† - ç¡®ä¿æ­£ç¡®çš„å­—èŠ‚åºå’Œæ•°å€¼èŒƒå›´
          const int16Array = new Int16Array(pcmData);
          for (let i = 0; i < int16Array.length; i++) {
              // é™åˆ¶æ ·æœ¬å€¼èŒƒå›´ï¼Œé˜²æ­¢å‰Šå³°
              const clampedSample = Math.max(-32768, Math.min(32767, int16Array[i]));
              view.setInt16(44 + i * 2, clampedSample, littleEndian);
          }
          
          return arrayBuffer;
      }

      // è¡¨å•æäº¤äº‹ä»¶
      document.getElementById('ttsForm').addEventListener('submit', async function(e) {
          e.preventDefault();
          
          const ttsText = document.getElementById('ttsText').value.trim();
          const instructText = document.getElementById('instructText').value.trim();
          const speed = parseFloat(document.getElementById('speed').value);
          const stream = document.getElementById('stream').checked;
          
          if (!ttsText) {
              showError('è¯·è¾“å…¥è¦åˆæˆçš„æ–‡æœ¬');
              return;
          }
          
          // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
          showLoading(true);
          hideMessages();
          
          // å¦‚æœæ˜¯æµå¼æ¨¡å¼ï¼Œæ˜¾ç¤ºæµå¼çŠ¶æ€å¹¶åˆå§‹åŒ–æ’­æ”¾å™¨
          if (stream) {
              document.getElementById('streamStatus').style.display = 'block';
              await streamPlayer.startStreaming();
          }
          
          try {
              const response = await fetch(base_url+'/cosyvoice', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                      tts_text: ttsText,
                      instruct_text: instructText || null,
                      stream: stream,
                      speed: speed,
                      volume: 2.0  // æé«˜é»˜è®¤éŸ³é‡ä»¥è·å¾—æ›´å¥½çš„éŸ³é¢‘è´¨é‡
                  })
              });
              
              if (!response.ok) {
                  throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              
              const contentType = response.headers.get('content-type');
              
              if (stream && response.body) {
                  streamPlayer.log('ğŸ“¡ å¼€å§‹æ¥æ”¶æµå¼éŸ³é¢‘æ•°æ®...');
                  
                  // æ£€æŸ¥æ˜¯å¦ä¸ºçœŸæ­£çš„æµå¼å“åº”
                  const isRealStream = response.headers.get('transfer-encoding') === 'chunked' || 
                                     response.headers.get('content-type')?.includes('stream') ||
                                     response.headers.get('content-type')?.includes('audio/pcm') ||
                                     response.headers.get('x-stream') === 'true';
                  
                  streamPlayer.log(`ğŸ” æ£€æµ‹æµå¼ç±»å‹: ${isRealStream ? 'çœŸå®æµå¼' : 'æ¨¡æ‹Ÿæµå¼'}`);
                  streamPlayer.log(`ğŸ“‹ å“åº”å¤´: Content-Type=${response.headers.get('content-type')}, Transfer-Encoding=${response.headers.get('transfer-encoding')}`);
                  
                  if (isRealStream) {
                      // çœŸæ­£çš„æµå¼å“åº” - å¤„ç†PCMæ•°æ®æµ
                      await streamPlayer.processRealTimeStream(response.body);
                  } else {
                      // æ¨¡æ‹Ÿæµå¼æ’­æ”¾ï¼ˆå°†å®Œæ•´éŸ³é¢‘æ•°æ®åˆ†å—å¤„ç†ï¼‰
                      const audioData = await response.arrayBuffer();
                      await streamPlayer.simulateStreamingPlayback(audioData);
                  }
                  
                  showSuccess(`æµå¼è¯­éŸ³åˆæˆå®Œæˆï¼`)
                  
              } else if (contentType && (contentType.includes('audio/wav') || contentType.includes('audio/pcm'))) {
                  // éæµå¼å¤„ç†
                  let audioData;
                  
                  if (contentType.includes('audio/pcm')) {
                      // PCMæ ¼å¼ - è½¬æ¢ä¸ºWAV
                      const arrayBuffer = await response.arrayBuffer();
                      const pcmData = new Int16Array(arrayBuffer);
                      audioData = pcmToWav(pcmData);
                  } else {
                      // WAVæ ¼å¼
                      audioData = await response.arrayBuffer();
                  }
                  
                  const audioBlob = new Blob([audioData], { type: 'audio/wav' });
                  const audioUrl = URL.createObjectURL(audioBlob);
                  
                  const audioPlayer = document.getElementById('audioPlayer');
                  const downloadLink = document.getElementById('downloadLink');
                  
                  audioPlayer.src = audioUrl;
                  downloadLink.href = audioUrl;
                  
                  document.getElementById('audioContainer').style.display = 'block';
                  showSuccess('è¯­éŸ³åˆæˆå®Œæˆï¼');
                  
              } else {
                  // å¤„ç†é”™è¯¯å“åº”
                  const errorText = await response.text();
                  throw new Error(errorText || 'æœªçŸ¥é”™è¯¯');
              }
              
          } catch (error) {
              console.error('TTSè¯·æ±‚å¤±è´¥:', error);
              showError(`è¯­éŸ³åˆæˆå¤±è´¥: ${error.message}`);
              if (stream) {
                  streamPlayer.stop();
              }
          } finally {
              showLoading(false);
          }
      });
      
      function showLoading(show) {
          document.getElementById('loading').style.display = show ? 'block' : 'none';
          document.getElementById('generateBtn').disabled = show;
      }
      
      function showError(message) {
          const errorDiv = document.getElementById('errorMsg');
          errorDiv.textContent = message;
          errorDiv.style.display = 'block';
      }
      
      function showSuccess(message) {
          const successDiv = document.getElementById('successMsg');
          successDiv.textContent = message;
          successDiv.style.display = 'block';
      }
      
      function hideMessages() {
          document.getElementById('errorMsg').style.display = 'none';
          document.getElementById('successMsg').style.display = 'none';
          document.getElementById('audioContainer').style.display = 'none';
      }

      // æ·»åŠ æµ‹è¯•å‡½æ•°åˆ°å…¨å±€ä½œç”¨åŸŸ
      window.testStreamTTS = async function(text = "è¿™æ˜¯ä¸€ä¸ªæµå¼è¯­éŸ³åˆæˆæµ‹è¯•") {
          console.log('ğŸ§ª å¼€å§‹æµå¼TTSæµ‹è¯•...');
          
          // è®¾ç½®æµ‹è¯•å‚æ•°
          document.getElementById('ttsText').value = text;
          document.getElementById('stream').checked = true;
          
          // è§¦å‘æäº¤
          const form = document.getElementById('ttsForm');
          const event = new Event('submit', { cancelable: true, bubbles: true });
          form.dispatchEvent(event);
          
          console.log('âœ… æµå¼TTSæµ‹è¯•å·²å¯åŠ¨');
      };
      
      // é¡µé¢åŠ è½½æ—¶æµ‹è¯•æœåŠ¡è¿æ¥å’Œå‡†å¤‡éŸ³é¢‘ä¸Šä¸‹æ–‡
      window.addEventListener('load', async function() {
          try {
              const response = await fetch(base_url+'/health'); 
              if (response.ok) {
                  console.log('TTSæœåŠ¡è¿æ¥æ­£å¸¸');
                  showSuccess('ğŸŸ¢ TTSæœåŠ¡è¿æ¥æ­£å¸¸');
              } else {
                  console.warn('TTSæœåŠ¡å¯èƒ½æœªå¯åŠ¨');
                  showError('ğŸ”´ TTSæœåŠ¡å¯èƒ½æœªå¯åŠ¨');
              }
          } catch (error) {
              console.warn('æ— æ³•è¿æ¥åˆ°TTSæœåŠ¡:', error);
              showError('ğŸ”´ æ— æ³•è¿æ¥åˆ°TTSæœåŠ¡: ' + error.message);
          }
          
          // æ·»åŠ ç”¨æˆ·äº¤äº’å¤„ç†ï¼Œç”¨äºç»•è¿‡è‡ªåŠ¨æ’­æ”¾é™åˆ¶
          document.addEventListener('click', function enableAutoplay() {
              if (streamPlayer.audioContext && streamPlayer.audioContext.state === 'suspended') {
                  streamPlayer.audioContext.resume().then(() => {
                      console.log('ğŸ”Š éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åœ¨ç”¨æˆ·äº¤äº’åæ¢å¤');
                      streamPlayer.updateStreamButtons(); // æ›´æ–°æŒ‰é’®çŠ¶æ€
                  });
              }
              // åªéœ€è¦æ‰§è¡Œä¸€æ¬¡
              document.removeEventListener('click', enableAutoplay);
          }, { once: true });
          
          // åœ¨æ§åˆ¶å°æ˜¾ç¤ºä½¿ç”¨æç¤º
          console.log('ğŸ’¡ æµå¼TTSä½¿ç”¨æç¤º:');
          console.log('   1. å‹¾é€‰"ğŸ”„ æµå¼åˆæˆ"é€‰é¡¹');
          console.log('   2. è¾“å…¥æ–‡æœ¬å¹¶ç‚¹å‡»"ğŸ¤ ç”Ÿæˆè¯­éŸ³"');
          console.log('   3. æˆ–è€…ç›´æ¥è¿è¡Œ: testStreamTTS("ä½ çš„æµ‹è¯•æ–‡æœ¬")');
          console.log('   4. å¦‚æœæ²¡æœ‰è‡ªåŠ¨æ’­æ”¾ï¼Œç‚¹å‡»é¡µé¢ä¸Šçš„"ğŸ”Š å¯ç”¨éŸ³é¢‘æ’­æ”¾"æŒ‰é’®');
      });
  </script>
</body>
</html>